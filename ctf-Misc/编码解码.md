# 常见加密

## 莫斯电码

```python
    #!/usr/bin/python
    # -*- coding: UTF-8 -*-
    def decode(a):
        plain_text=''
        s = a.split(" ")
        dict = {
                '.-':'A','-...':'B','-.-.':'C','-..':'D','.':'E','..-.':'F','--.':'G','....':'H',
                '..':'I','.---':'J','-.-':'K','.-..':'L','--':'M','-.':'N','---':'O','.--.':'P',
                '--.-':'Q','.-.':'R','...':'S','-':'T','..-':'U','...-':'V','.--':'W','-..-':'X',
                '-.--':'Y','--..':'Z','.----':'1','..---':'2','...--':'3','....-':'4','.....':'5',
                '-....':'6','--...':'7','---..':'8','----.':'9','-----':'0','..--..':'?','-..-.':'/',
                '-.--.-':'()','-....-':'-','.-.-.-':'.'
                };
        for item in s:
            plain_text+=dict[item]
        return plain_text
    str1='111 000 11 111 111 000 1111'
    cipher_text=''
    for i in str1:
        try:
            if i==' ':
                cipher_text+=i
            else:
                if i=='1':
                    cipher_text+='-'
                elif i=='0':
                    cipher_text+="."
        except Exception as err:
            print(err)
    print(decode(cipher_text).lower())
```

## ROT13

```python
    def Upper(ch):
        if ch>='A' and ch<='Z':
            return True

    def Lower(ch):
        if ch>='a' and ch<='z':
            return True

    def rot13(s):
        flag = ''
        for i in s:
            if Upper(i) == True:
                if i>='A' and i<='M':
                    flag += chr(ord(i)+13)
                else:
                    flag += chr(ord(i)-13)
            elif Lower(i) == True:
                if i>='a' and i<='m':
                    flag += chr(ord(i)+13)
                else:
                    flag += chr(ord(i)-13)
            else:
                flag += i
        return flag

    if __name__ == "__main__":
        s = input('ciphertext:')
        print(rot13(s))
```

## 栅栏

```python
    #coding = utf-8
    e='ngn_qp{qdudtms0u1fz}'
    elen = len(e)
    filed = []
    for i in range(2,elen):
        if(elen%i==0):
            filed.append(i)
    for f in filed:
        b = elen
        result = {x:'' for x in range(b)}
        for i in range(elen):
            a = i%b
            result.update({a:result[a]+e[i]})
        d=''
        for i in range(b):
            d = d+result[i]
        print('分为'+str(f)+'栏时，解密结果为：'+d+'\n')
```

## RC4

```java
    public class X_system{
        public static void main(String[] args) {
            String key = "Flag{This_Not_Flag}";
            String enFlag = "52aedea36a3c058b38aa32e625889947db302a6d1defdabf413085abf611487bf445e85108327a867c27";
            String flag;
            flag = decry_RC4(enFlag, key);
            System.out.println(flag);
        }

        private static byte[] HexString2Bytes(String arg6) {
            int v2 = arg6.length();
            byte[] v1 = new byte[v2 / 2];
            byte[] v3 = arg6.getBytes();
            int v0;
            for(v0 = 0; v0 < v2 / 2; ++v0) {
                v1[v0] = X_system.uniteBytes(v3[v0 * 2], v3[v0 * 2 + 1]);
            }

            return v1;
        }

        private static byte[] RC4Base(byte[] arg9, String arg10) {
            int v4 = 0;
            int v6 = 0;
            byte[] v1 = X_system.initKey(arg10);
            byte[] v2 = new byte[arg9.length];
            int v0;
            for(v0 = 0; v0 < arg9.length; ++v0) {
                v4 = v4 + 1 & 255;
                v6 = (v1[v4] & 255) + v6 & 255;
                byte v3 = v1[v4];
                v1[v4] = v1[v6];
                v1[v6] = v3;
                v2[v0] = ((byte)(arg9[v0] ^ v1[(v1[v4] & 255) + (v1[v6] & 255) & 255]));
            }

            return v2;
        }

        private static String asString(byte[] arg3) {
            StringBuffer v1 = new StringBuffer(arg3.length);
            int v0;
            for(v0 = 0; v0 < arg3.length; ++v0) {
                v1.append(((char)arg3[v0]));
            }

            return v1.toString();
        }

        private static byte uniteBytes(byte arg8, byte arg9) {
            return ((byte)((((char)((((char)Byte.decode("0x" + new String(new byte[]{arg8})).byteValue())) << 4))) ^ (((char)Byte.decode("0x" + new String(new byte[]{arg9})).byteValue()))));
        }

        // 解密函数decry_RC4，有重载，两个函数分别对应传入的字符串参数和字节参数
        public static String decry_RC4(String arg2, String arg3) {
            String v0 = arg2 == null || arg3 == null ? null : new String(X_system.RC4Base(X_system.HexString2Bytes(arg2), arg3));
            return v0;
        }
        public static String decry_RC4(byte[] arg1, String arg2) {
            String v0 = arg1 == null || arg2 == null ? null : X_system.asString(X_system.RC4Base(arg1, arg2));
            return v0;
        }

        // 加密函数，返回值为byte
        public static byte[] encry_RC4_byte(String arg2, String arg3) {
            byte[] v1 = arg2 == null || arg3 == null ? null : X_system.RC4Base(arg2.getBytes(), arg3);
            return v1;
        }

        // 加密函数，返回值为字符串
        public static String encry_RC4_string(String arg1, String arg2) {
            String v0 = arg1 == null || arg2 == null ? null : X_system.toHexString(X_system.asString(X_system.encry_RC4_byte(arg1, arg2)));
            return v0;
        }

        // 初始化密钥
        private static byte[] initKey(String arg9) {
            int v8 = 256;
            byte[] v0 = arg9.getBytes();
            byte[] v4 = new byte[v8];
            int v1;
            for(v1 = 0; v1 < v8; ++v1) {
                v4[v1] = ((byte)v1);
            }

            int v2 = 0;
            int v3 = 0;
            if(v0 == null || v0.length == 0) {
                return null;
            }
            else {
                v1 = 0;
                while(v1 < v8) {
                    v3 = (v0[v2] & 255) + (v4[v1] & 255) + v3 & 255;
                    byte v5 = v4[v1];
                    v4[v1] = v4[v3];
                    v4[v3] = v5;
                    v2 = (v2 + 1) % v0.length;
                    ++v1;
                }
            }
            return v4;
        }

        public static String str2HexStr(String arg6) {
            char[] v2 = "0123456789ABCDEF".toCharArray();
            StringBuilder v4 = new StringBuilder("");
            byte[] v1 = arg6.getBytes();
            int v3;
            for(v3 = 0; v3 < v1.length; ++v3) {
                v4.append(v2[(v1[v3] & 240) >> 4]);
                v4.append(v2[v1[v3] & 15]);
                v4.append(' ');
            }

            return v4.toString().trim();
        }

        private static String toHexString(String arg6) {
            String v3 = "";
            int v1;
            for(v1 = 0; v1 < arg6.length(); ++v1) {
                String v2 = Integer.toHexString(arg6.charAt(v1) & 255);
                if(v2.length() == 1) {
                    v2 = '0' + v2;
                }
                v3 = v3 + v2;
            }
            return v3;
        }
    }
```

## 差分曼彻斯特

```python
    a = 0x9a9a9a6a9aa9656699a699a566995956996a996aa6a965aa9a6aa596a699665a9aa699655a696569655a9a9a9a595a6965569a59665566955a6965a9596a99aa9a9566a699aa9a969969669aa6969a9559596669
    b = 0x9a9a9a6a9aa9656699a699a566995956996a996aa6a965aa9a6aa596a699665a9aa699655a696569655a9a9a9a595a6965569a59665566955a6965a9596a99aa9a9566a699aa9a969969669aa6969a9559596669
    b2 = bin(b)
    #print(b2)
    str1 = ""
    for i in range(int(len(b2[2:])/2)):
        a1 = b2[i*2:i*2+2]
        a2 = b2[i*2+2:i*2+4]
        if a2 !='10' and a2 !='01':
            continue
        if a1 !='10' and a1 !='01':
            continue
        if a1!=a2:
            str1+='1'
        else:
            str1+='0'
    # print(str1)
    flag=hex(int(str1,2)).upper()
    print(flag)
    flag=bytes.fromhex(flag[2:])
    print(flag)
```

## base64更换码表

```python
    from base64 import b64decode
    table="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
    t="".join([chr(i) for i in range(48, 48+64)]) + " "
    #print(t)
    #print(table)

    table = str.maketrans(t,table)
    en_str="IVaQIg]:DfDcL7=VN64bF3TfEE=WCCDh<c@fM3ADHCPgME9ANGd "
    flag = en_str.translate(table)
    #print(flag)

    flag = b64decode(flag)
    print(flag)
```
